import type { RequestHandler } from '@sveltejs/kit';

/**
 * SvelteKit 2 API Route: SOM Training
 * POST /api/clustering/som/train
 */

import { json } from "@sveltejs/kit";
import { LegalDocumentSOM } from "$lib/services/som-clustering";
import { Redis } from "ioredis";
import { legalDocuments } from "$lib/server/db/schema-postgres";
import { URL } from "url";
// Optional amqp for message queue integration

// Initialize Redis connection
const redis = new Redis(
  parseInt(import.meta.env.REDIS_PORT || "6379"),
import.meta.env.REDIS_HOST || "localhost" ); // RabbitMQ connection (optional) let rabbitConnection: any | null = null; async function getRabbitConnection() { if (!rabbitConnection) { try { // const amqp = await import('amqplib').catch(() => null); // if (amqp) { // rabbitConnection = await amqp.connect(import.meta.env.RABBITMQ_URL || 'amqp://localhost'); // } } catch (error) { console.warn("RabbitMQ not available:", error); } } return rabbitConnection; } export const POST: RequestHandler = async ({ request }) => { const startTime = Date.now(); try { const { documentIds, config } = await request.json(); if ( !documentIds || !Array.isArray(documentIds) || documentIds.length === 0 ) { return json( { success: false, error: "Document IDs array is required", metadata: { timestamp: new Date().toISOString(), processingTime: Date.now() - startTime } }, { status: 400 }, ); } // Fetch document embeddings from PostgreSQL with pgvector const documentRecords = await db .select({ id: legalDocuments.id, embedding: legalDocuments.embedding, metadata: legalDocuments.keywords, // Use keywords as metadata }) .from(legalDocuments) .where(inArray(legalDocuments.id, documentIds)); if (documentRecords.length === 0) { return json( { success: false, error: "No documents found with provided IDs", metadata: { timestamp: new Date().toISOString(), processingTime: Date.now() - startTime } }, { status: 404 }, ); } // Extract embeddings (assuming they're stored as arrays) const embeddings: number[][] = documentRecords .map((doc) => doc.embedding) .filter((embedding) => Array.isArray(embedding) && embedding.length > 0); if (embeddings.length === 0) { return json( { success: false, error: "No valid embeddings found in documents", metadata: { timestamp: new Date().toISOString(), processingTime: Date.now() - startTime } }, { status: 400 }, ); } // Create SOM configuration const somConfig = { width: config?.width || 20, height: config?.height || 20, learningRate: config?.learningRate || 0.5, radius: config?.radius || 5, iterations: config?.iterations || 1000, maxIterations: config?.maxIterations || 1000, // Required property tolerance: config?.tolerance || 0.001, // Required property dimensions: embeddings[0].length, // Infer from first embedding // Required properties for SOMConfig algorithm: "som" as const, gridWidth: config?.width || 20, gridHeight: config?.height || 20, k: config?.k || 10, // Number of clusters distanceMetric: "euclidean" as const, topology: "hexagonal" as const }; // Generate training ID for tracking const trainingId = `som_training_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`; // Queue training job in RabbitMQ (optional) const connection = await getRabbitConnection(); let channel: any = null; if (connection) { try { channel = await connection.createChannel(); await channel.assertExchange("clustering", "topic", { durable: true }); const message = { messageId: trainingId, type: "som_training", payload: { documentIds, embeddings, config: somConfig, metadata: { requestedAt: new Date().toISOString(), documentCount: embeddings.length } }, priority: "high", timestamp: new Date().toISOString() }; await channel.publish( "clustering", "som.training.start", Buffer.from(JSON.stringify(message)), { persistent: true }, ); } catch (error) { console.warn("Failed to queue RabbitMQ message:", error); } } // Store training status in Redis await redis.hset(`som:training:${trainingId}`, { status: "queued", documentCount: embeddings.length, config: JSON.stringify(somConfig), startedAt: Date.now() }); // Estimate training time (rough calculation) const estimatedTimeMs = somConfig.iterations * embeddings.length * 0.001; // 1ms per iteration per document // Start background training process setImmediate(async () => { try { await redis.hset(`som:training:${trainingId}`, "status", "processing"); const som = new LegalDocumentSOM(somConfig, redis); await som.train(embeddings); // Analyze clusters const analysis = await som.analyzeLegalClusters( documentRecords.map((doc) => ({ id: doc.id, embedding: doc.embedding as number[], metadata: doc.metadata || {} })), ); await redis.hset(`som:training:${trainingId}`, { status: "completed", completedAt: Date.now(), clusters: JSON.stringify(analysis.clusters) }); // Publish completion event (if RabbitMQ available) if (channel) { try { await channel.publish( "clustering", "som.training.completed", Buffer.from( JSON.stringify({ trainingId, status: "completed", analysis }), ), ); } catch (error) { console.warn("Failed to publish completion event:", error); } } } catch (error) { console.error("SOM training failed:", error); await redis.hset(`som:training:${trainingId}`, { status: "failed", error: error instanceof Error ? error.message : "Unknown error", failedAt: Date.now() }); // Publish failure event (if RabbitMQ available) if (channel) { try { await channel.publish( "clustering", "som.training.failed", Buffer.from( JSON.stringify({ trainingId, status: "failed", error: error instanceof Error ? error.message : "Unknown error" }), ), ); } catch (error) { console.warn("Failed to publish failure event:", error); } } } finally { if (channel) { try { await channel.close(); } catch (error) { console.warn("Failed to close RabbitMQ channel:", error); } } } }); return json({ success: true, data: { trainingId, estimatedTime: Math.round(estimatedTimeMs / 1000), // Convert to seconds documentCount: embeddings.length, queuePosition: 1, // Since we're processing immediately }, metadata: { timestamp: new Date().toISOString(), processingTime: Date.now() - startTime, clusterId: trainingId } }); } catch (error) { console.error("SOM training API error:", error); return json( { success: false, error: error instanceof Error ? error.message : "Internal server error", metadata: { timestamp: new Date().toISOString(), processingTime: Date.now() - startTime } }, { status: 500 }, ); } }; // GET endpoint to check training status export const GET: RequestHandler = async ({ url }) => { const trainingId = url.searchParams.get("trainingId"); if (!trainingId) { return json( { success: false, error: "Training ID is required", metadata: { timestamp: new Date().toISOString(), processingTime: 0 } }, { status: 400 }, ); } try { const status = await redis.hgetall(`som:training:${trainingId}`); if (Object.keys(status).length === 0) { return json( { success: false, error: "Training ID not found", metadata: { timestamp: new Date().toISOString(), processingTime: 0 } }, { status: 404 }, ); } return json({ success: true, data: { trainingId, status: status.status, documentCount: parseInt(status.documentCount || "0"), startedAt: status.startedAt ? new Date(parseInt(status.startedAt)) : null, completedAt: status.completedAt ? new Date(parseInt(status.completedAt)) : null, clusters: status.clusters ? JSON.parse(status.clusters) : null, error: status.error || null }, metadata: { timestamp: new Date().toISOString(), processingTime: 5 } }); } catch (error) { console.error("SOM status check error:", error); return json( { success: false, error: "Failed to retrieve training status", metadata: { timestamp: new Date().toISOString(), processingTime: 0 } }, { status: 500 }, ); } };