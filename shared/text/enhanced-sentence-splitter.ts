/**
 * Enhanced Sentence Splitter for text processing (shared)
 */

interface SplitterOptions { minLength?: number; maxLength?: number; minFragmentLength?: number; mergeThreshold?: number; streamBufferSize?: number; headingPatterns?: RegExp[]; }
interface StreamingContext { buffer: string; processedSentences: string[]; }

export class EnhancedSentenceSplitter {
  private minLength: number; private maxLength: number; private minFragmentLength: number; private mergeThreshold: number; private streamBufferSize: number; private customAbbreviations: Set<string>; private abbreviationRegexes: { abbr: string; regex: RegExp }[]; private headingPatterns: RegExp[];
  private readonly defaultAbbreviations = new Set(['Inc.', 'Corp.', 'Ltd.', 'L.L.C.', 'LLC', 'P.C.', 'P.A.', 'U.S.', 'U.S.C.', 'U.S.A.', 'Art.', 'Sec.', 'Para.', 'v.', 'vs.', 'No.', 'Dr.', 'Mr.', 'Mrs.', 'Ms.', 'Ph.D.', 'M.D.', 'J.D.', 'Esq.', 'Jr.', 'Sr.', 'Co.', 'Bros.', 'Assoc.', 'Dept.', 'Est.', 'Jan.', 'Feb.', 'Mar.', 'Apr.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Sept.', 'Oct.', 'Nov.', 'Dec.', 'Mon.', 'Tue.', 'Wed.', 'Thu.', 'Fri.', 'Sat.', 'Sun.', 'Cust.', 'Spec.', 'e.g.', 'i.e.', 'cf.', 'et al.']);
  constructor(options: SplitterOptions = {}) { this.minLength = options.minLength || 10; this.maxLength = options.maxLength || 500; this.minFragmentLength = options.minFragmentLength || 20; this.mergeThreshold = options.mergeThreshold || 15; this.streamBufferSize = options.streamBufferSize || 100; this.customAbbreviations = new Set(); this.abbreviationRegexes = Array.from(this.defaultAbbreviations).filter(a => a !== 'No.').map(abbr => ({ abbr, regex: new RegExp(abbr.replace(/\./g, '\\.'), 'g') })); this.headingPatterns = options.headingPatterns || [/^(Section|Chapter|Article|Exhibit|Annex|Appendix|Schedule)\s+(?:[0-9]+|[IVXLC]+|[A-Z])\.$/i]; }
  addAbbreviations(abbreviations: string[]): void { abbreviations.forEach(abbr => this.customAbbreviations.add(abbr)); }
  splitSentences(text: string): string[] { return this.split(text); }
  split(text: string): string[] { if (!text || !text.trim()) return []; const allAbbreviations = new Set([...this.defaultAbbreviations, ...this.customAbbreviations]); let protectedText = text; const replacements: Map<string, string> = new Map(); let replacementIndex = 0; if (allAbbreviations.has('No.')) { const placeholder = `__ABBR_${replacementIndex++}__`; replacements.set(placeholder, 'No.'); protectedText = protectedText.replace(/No\.(?=\s+\d)/g, placeholder); } this.abbreviationRegexes.forEach(({ abbr, regex }) => { if (!allAbbreviations.has(abbr)) return; const placeholder = `__ABBR_${replacementIndex++}__`; replacements.set(placeholder, abbr); protectedText = protectedText.replace(regex, placeholder); }); const sentences = protectedText.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || []; const processedSentences = sentences.map(sentence => { let restored = sentence.trim(); replacements.forEach((original, placeholder) => { restored = restored.replace(new RegExp(placeholder, 'g'), original); }); return restored; }); for (let i = 0; i < processedSentences.length - 1; i++) { const heading = processedSentences[i].trim(); if (this.headingPatterns.some(r => r.test(heading))) { processedSentences[i + 1] = processedSentences[i] + ' ' + processedSentences[i + 1]; processedSentences.splice(i, 1); i--; } } return this.mergeFragments(processedSentences); }
  private mergeFragments(sentences: string[]): string[] { const result: string[] = []; let i = 0; while (i < sentences.length) { const current = sentences[i]; const curLen = current.length; const terminal = current.at(-1) || ''; const isForceKeep = /[!?]/.test(terminal); if (curLen >= this.minFragmentLength || isForceKeep) { result.push(current); i++; continue; } const runStart = i; let runEnd = i; while (runEnd + 1 < sentences.length && sentences[runEnd + 1].length < this.minFragmentLength && /\.$/.test(sentences[runEnd + 1].trim())) { runEnd++; } const nextSentence = sentences[runEnd + 1]; const hasFollowingLong = !!nextSentence && nextSentence.length >= this.minFragmentLength; if (runEnd === runStart && hasFollowingLong) { sentences[runEnd + 1] = sentences[runStart] + ' ' + nextSentence; i = runEnd + 1; continue; } if (runEnd > runStart && hasFollowingLong) { i = runEnd + 1; continue; } for (let j = runStart; j <= runEnd; j++) { if (sentences[j].length >= this.minLength) result.push(sentences[j]); } i = runEnd + 1; } return result.filter(s => s.length <= this.maxLength); }
  splitIntoChunks(text: string, chunkSize: number = 1000): string[] { const chunks: string[] = []; const sentences = this.split(text); let currentChunk = ''; for (const sentence of sentences) { if ((currentChunk + sentence).length > chunkSize && currentChunk) { chunks.push(currentChunk.trim()); currentChunk = sentence; } else { currentChunk += (currentChunk ? ' ' : '') + sentence; } } if (currentChunk) chunks.push(currentChunk.trim()); return chunks; }
  processStreamingChunk(chunk: string, context: StreamingContext): string[] { context.buffer += chunk; const sentences: string[] = []; const matches = context.buffer.match(/[^.!?]+[.!?]+/g); if (matches) { matches.forEach(match => { const processed = this.split(match.trim()); sentences.push(...processed); }); const lastMatch = matches[matches.length - 1]; const lastIndex = context.buffer.lastIndexOf(lastMatch) + lastMatch.length; context.buffer = context.buffer.substring(lastIndex); if (context.buffer.length > this.streamBufferSize) { const frag = context.buffer.trim(); if (frag.length >= this.minLength) { sentences.push(frag); context.processedSentences.push(frag); context.buffer = ''; } } } context.processedSentences.push(...sentences); return sentences; }
  finalizeStreaming(context: StreamingContext): string[] { const remaining = context.buffer.trim(); if (remaining) { let sentences = this.split(remaining); if (sentences.length === 0 && remaining.length >= this.minLength) { sentences = [remaining]; } context.processedSentences.push(...sentences); return sentences; } return []; }
}
export default EnhancedSentenceSplitter;
export function splitSentencesEnhanced(text: string): string[] { return new EnhancedSentenceSplitter().split(text); }
export function createStreamingSplitter(options: SplitterOptions = {}): { splitter: EnhancedSentenceSplitter; context: StreamingContext; } { const splitter = new EnhancedSentenceSplitter(options); const context: StreamingContext = { buffer: '', processedSentences: [] }; return { splitter, context }; }
