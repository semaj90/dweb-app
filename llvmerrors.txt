
In PowerShell (replace 13.0 with the exact folder name you have under C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA):

powershell
Copy
Edit
setx PATH "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v13.0\bin;%PATH%"
setx PATH "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v13.0\libnvvp;%PATH%"
Verify:

powershell
Copy
Edit
nvcc --version
You should see something like:

arduino
Copy
Edit
Cuda compilation tools, release 13.0, V13.0.xxx
2Ô∏è‚É£ Make CGO Use Clang
Since we‚Äôre mixing CUDA, WebGPU, and Go, LLVM/Clang is still the safest bet:

powershell
Copy
Edit
setx CC "clang"
setx CXX "clang++"
setx CGO_ENABLED 1
3Ô∏è‚É£ Install Go GPU/WebGPU/JSON Dependencies
powershell
Copy
Edit
go get github.com/tidwall/gjson
go get github.com/sashabaranov/go-openai
go get github.com/rajveermalviya/go-webgpu
4Ô∏è‚É£ VS Code .vscode/settings.json
json
Copy
Edit
{
  "go.buildFlags": ["-tags=cgo"],
  "go.toolsEnvVars": {
    "CC": "clang",
    "CXX": "clang++",
    "CGO_ENABLED": "1"
  }
}
5Ô∏è‚É£ Minimal Go + CGO + CUDA 13 Example
This will:

Call CUDA from Go via CGO

Print a GPU message (as proof)

Parse JSON using gjson

main.go:

go
Copy
Edit
package main

/*
#cgo LDFLAGS: -lcudart
#include <cuda_runtime.h>
#include <stdio.h>

__global__ void hello_from_gpu() {
    printf("Hello from CUDA 13 GPU kernel!\\n");
}

void runGPU() {
    hello_from_gpu<<<1,1>>>();
    cudaDeviceSynchronize();
}
*/
import "C"

import (
    "fmt"
    "github.com/tidwall/gjson"
)

func main() {
    // GPU Test
    C.runGPU()

    // JSON Parsing Test
    data := `{"rag": {"embedding": [0.12, 0.87, 0.33], "query": "test"}}`
    query := gjson.Get(data, "rag.query").String()
    fmt.Println("Parsed query from JSON:", query)
}
Run it:

powershell
Copy
Edit
go run main.go
Expected output:

javascript
Copy
Edit
Hello from CUDA 13 GPU kernel!
Parsed query from JSON: test
6Ô∏è‚É£ SvelteKit 2 + Go Bridge
In SvelteKit, you can call the Go backend via WebSocket or REST.

Example dev proxy in vite.config.js:

js
Copy
Edit
export default {
  server: {
    proxy: {
      '/api': 'http://localhost:8080'
    }
  }
}
In Go, add an HTTP/WebSocket listener so your Svelte frontend can push JSON to be parsed and processed on the GPU.




Use Ollama's HTTP API for GPU operations. It works now.
Consolidate to single service on 8080.
simdjson-go provides SIMD without CGO.
do i need this for go microservice? 
t it ‚Äî your Go build is failing because Windows is tripping over the C:\Program Files\... space issue in your compiler path.

Here‚Äôs what‚Äôs happening:

CGO_ENABLED=1 tells Go to compile C/C++ parts (needed for SIMD or cuBLAS).

set CXX=clang++ points to your C++ compiler, but if Clang/LLVM or MSVC is installed in C:\Program Files\..., the space in the path breaks the call unless it‚Äôs quoted.

On Windows, cgo doesn‚Äôt handle spaces in the compiler path unless you fix your PATH or use the short path name.
 Use quotes around the compiler path
If you know where clang++ lives (for example in LLVM):

powershell
Copy
Edit
set "CXX=C:\Program Files\LLVM\bin\clang++.exe"
The set "VAR=VALUE" format preserves spaces.

2. Use Windows short path names
You can get the short path like this:

powershell
Copy
Edit
for %I in ("C:\Program Files\LLVM\bin\clang++.exe") do @echo %~sI
Example output:

makefile
Copy
Edit
C:\PROGRA~1\LLVM\bin\clang++.exe
Then:

powershell
Copy
Edit
set CXX=C:\PROGRA~1\LLVM\bin\clang++.exe
3. Add compiler to PATH without spaces
You could copy LLVM or MinGW into a folder like C:\LLVM and update:

powershell
Copy
Edit
set PATH=C:\LLVM\bin;%PATH%
set CXX=clang++
4. If you need cuBLAS / CUDA
For cuBLAS support, ensure CUDA toolkit‚Äôs bin and lib directories are in PATH and CGO_LDFLAGS points to the right .lib or .dll. Example:

powershell
Copy
Edit
set CUDA_PATH=C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v12.8
set PATH=%CUDA_PATH%\bin;%PATH%
set CGO_LDFLAGS=-L"%CUDA_PATH%\lib\x64" -lcublas -lcudart
Since you‚Äôre building Go + SIMD + cuBLAS for your SvelteKit WebGPU service, my next suggestion would be to first confirm we can compile a simple CGO hello-world with clang++ before we integrate the SIMD/cuBLAS code. That way we isolate the build issue from the actual math module.

If you want, I can give you a minimal Go+CGO+cuBLAS test program to verify your build pipeline before we plug it into the WebGPU intent caching UI. That will prove both the compiler and CUDA bindings are working.
minimal Go+CGO+cuBLAS test program to verify your build pipeline before we plug it into the WebGPU intent caching UI. That will prove both the compiler and CUDA bindings are working. yes

package main

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/bytedance/sonic"
	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/neo4j/neo4j-go-driver/v5/neo4j"
)

// --- Configuration ---
const (
	postgresURL       = "postgres://legal_admin:LegalAI2024!@localhost:5432/legal_ai_db"
	neo4jURI          = "bolt://localhost:7687"
	neo4jUser         = "neo4j"
	neo4jPassword     = "legalai123"
	ollamaAPI         = "http://localhost:11434/api"
	sveltekitAPI      = "http://localhost:5173/api" // Base URL for SvelteKit backend
	analysisOutputDir = "./generated_reports"      // Directory to save analysis files
)

// --- Structs for API Payloads ---

type FilePathsPayload struct {
	FilePaths []string `json:"filePaths"`
}

type OllamaEmbedRequest struct {
	Model  string `json:"model"`
	Prompt string `json:"prompt"`
}

type OllamaEmbedResponse struct {
	Embedding []float32 `json:"embedding"`
}

type OllamaGenerateRequest struct {
	Model  string `json:"model"`
	Prompt string `json:"prompt"`
	Format string `json:"format,omitempty"`
	Stream bool   `json:"stream"`
}

type OllamaGenerateResponse struct {
	Response string `json:"response"`
}

// Struct for the final analysis report generated by the LLM
type AnalysisReport struct {
	FilePath        string   `json:"filePath"`
	Severity        string   `json:"severity"`
	IssueSummary    string   `json:"issueSummary"`
	Recommendations []string `json:"recommendations"`
	TodoList        []string `json:"todoList"`
}

// --- Main Application ---

func main() {
	// --- Ensure output directory exists ---
	if err := os.MkdirAll(analysisOutputDir, 0755); err != nil {
		log.Fatalf("Failed to create output directory: %v", err)
	}

	// --- Database Connections ---
	ctx := context.Background()
	dbpool, err := pgxpool.New(ctx, postgresURL)
	if err != nil {
		log.Fatalf("Unable to connect to PostgreSQL: %v\n", err)
	}
	defer dbpool.Close()
	log.Println("‚úÖ Connected to PostgreSQL")

	driver, err := neo4j.NewDriverWithContext(neo4jURI, neo4j.BasicAuth(neo4jUser, neo4jPassword, ""))
	if err != nil {
		log.Fatalf("Unable to connect to Neo4j: %v\n", err)
	}
	defer driver.Close(ctx)
	log.Println("‚úÖ Connected to Neo4j")

	// --- Gin Router Setup ---
	router := gin.Default()

	// Health check endpoint for the launcher to ping
	router.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	router.POST("/batch-process-files", func(c *gin.Context) {
		var payload FilePathsPayload
		body, _ := io.ReadAll(c.Request.Body)

		if err := sonic.Unmarshal(body, &payload); err != nil {
			c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid JSON payload"})
			return
		}

		// Run processing in the background so the API can respond immediately
		go processFiles(payload.FilePaths, dbpool, driver)

		c.JSON(http.StatusAccepted, gin.H{"status": "processing_started", "file_count": len(payload.FilePaths)})
	})

	log.Println("üöÄ Go microservice listening on :8080")
	router.Run(":8080")
}

// --- Core Processing Logic ---

func processFiles(paths []string, dbpool *pgxpool.Pool, driver neo4j.DriverWithContext) {
	var wg sync.WaitGroup
	sem := make(chan struct{}, 16)

	for _, path := range paths {
		wg.Add(1)
		go func(filePath string) {
			defer wg.Done()
			sem <- struct{}{}
			defer func() { <-sem }()

			log.Printf("Processing: %s\n", filePath)

			content, err := os.ReadFile(filePath)
			if err != nil {
				log.Printf("Error reading file %s: %v\n", filePath, err)
				return
			}
			textContent := string(content)

			var embedding []float32
			var summary string
			var aiWg sync.WaitGroup
			aiWg.Add(2)

			go func() {
				defer aiWg.Done()
				emb, err := getOllamaEmbedding(textContent, "nomic-embed-text")
				if err != nil {
					log.Printf("Embedding failed for %s: %v\n", filePath, err)
				}
				embedding = emb
			}()

			go func() {
				defer aiWg.Done()
				sum, err := getOllamaSummary(textContent, "gemma3-legal")
				if err != nil {
					log.Printf("Summarization failed for %s: %v\n", filePath, err)
				}
				summary = sum
			}()
			aiWg.Wait()

			if embedding == nil || summary == "" {
				log.Printf("Skipping database insertion for %s due to AI processing errors.\n", filePath)
				return
			}

			storeInPostgres(filePath, textContent, embedding, summary, dbpool)
			storeInNeo4j(filePath, summary, driver)

			// --- New Step: Generate and save analysis reports ---
			analysisReport, err := analyzeAndSaveReports(filePath, textContent, summary)
			if err != nil {
				log.Printf("Analysis failed for %s: %v\n", filePath, err)
			} else {
				// --- Notify SvelteKit that a new analysis is ready ---
				notifySvelteKit("/analysis/complete", analysisReport)
			}

		}(path)
	}

	wg.Wait()
	log.Println("‚úÖ Batch processing complete.")
}

// --- Helper Functions ---

func getOllamaEmbedding(text string, model string) ([]float32, error) {
	reqData, _ := sonic.Marshal(OllamaEmbedRequest{Model: model, Prompt: text})
	return doOllamaRequest[OllamaEmbedResponse](fmt.Sprintf("%s/embeddings", ollamaAPI), reqData, func(r OllamaEmbedResponse) []float32 {
		return r.Embedding
	})
}

func getOllamaSummary(text string, model string) (string, error) {
	prompt := fmt.Sprintf("Summarize the following code file in a concise paragraph:\n\n%s", text)
	reqData, _ := sonic.Marshal(OllamaGenerateRequest{Model: model, Prompt: prompt, Stream: false})
	return doOllamaRequest[OllamaGenerateResponse](fmt.Sprintf("%s/generate", ollamaAPI), reqData, func(r OllamaGenerateResponse) string {
		return r.Response
	})
}

func analyzeAndSaveReports(filePath, content, summary string) (*AnalysisReport, error) {
	prompt := fmt.Sprintf(
		`You are an expert software architect. Analyze the following code file and its summary to identify potential issues and create a to-do list.
		File Path: %s
		Summary: %s
		Content:
		---
		%s
		---
		Based on this, provide a JSON object with the following structure: { "severity": "...", "issueSummary": "...", "recommendations": ["...", "..."], "todoList": ["...", "..."] }`,
		filePath, summary, content,
	)

	reqData, _ := sonic.Marshal(OllamaGenerateRequest{Model: "gemma3-legal", Prompt: prompt, Format: "json", Stream: false})
	analysisJSON, err := doOllamaRequest[OllamaGenerateResponse](fmt.Sprintf("%s/generate", ollamaAPI), reqData, func(r OllamaGenerateResponse) string {
		return r.Response
	})

	if err != nil {
		return nil, err
	}

	var report AnalysisReport
	if err := sonic.Unmarshal([]byte(analysisJSON), &report); err != nil {
		return nil, fmt.Errorf("failed to unmarshal analysis report: %v", err)
	}
	report.FilePath = filePath

	// --- Save reports to files ---
	baseName := filepath.Base(filePath)
	// JSON Report (for LLM/tooling)
	os.WriteFile(filepath.Join(analysisOutputDir, baseName+".json"), []byte(analysisJSON), 0644)
	// TXT Report (for human summary)
	txtContent := fmt.Sprintf("Analysis for: %s\nSeverity: %s\n\nSummary:\n%s\n\nRecommendations:\n- %s\n\nTo-Do:\n- %s",
		report.FilePath, report.Severity, report.IssueSummary, strings.Join(report.Recommendations, "\n- "), strings.Join(report.TodoList, "\n- "))
	os.WriteFile(filepath.Join(analysisOutputDir, baseName+".txt"), []byte(txtContent), 0644)
	// MD Report (for GitHub)
	mdContent := fmt.Sprintf("# Analysis Report: `%s`\n\n**Severity**: %s\n\n## Issue Summary\n%s\n\n## Recommendations\n- %s\n\n## To-Do List\n- [ ] %s",
		report.FilePath, report.Severity, report.IssueSummary, strings.Join(report.Recommendations, "\n- "), strings.Join(report.TodoList, "\n- [ ] "))
	os.WriteFile(filepath.Join(analysisOutputDir, baseName+".md"), []byte(mdContent), 0644)

	log.Printf("Generated analysis reports for %s", filePath)
	return &report, nil
}

// Generic function to handle Ollama API requests
func doOllamaRequest[T any, R any](url string, body []byte, extractor func(T) R) (R, error) {
	var zero R
	client := &http.Client{Timeout: 120 * time.Second} // Increased timeout for analysis
	req, _ := http.NewRequest("POST", url, bytes.NewBuffer(body))
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return zero, err
	}
	defer resp.Body.Close()

	respBody, _ := io.ReadAll(resp.Body)
	if resp.StatusCode != http.StatusOK {
		return zero, fmt.Errorf("Ollama API error (%d): %s", resp.StatusCode, string(respBody))
	}

	var apiResp T
	if err := sonic.Unmarshal(respBody, &apiResp); err != nil {
		return zero, fmt.Errorf("failed to parse Ollama response: %s", string(respBody))
	}

	return extractor(apiResp), nil
}

func storeInPostgres(path, content string, embedding []float32, summary string, dbpool *pgxpool.Pool) {
	embeddingStr := fmt.Sprintf("[%s]", strings.Trim(fmt.Sprint(embedding), "[]"))
	_, err := dbpool.Exec(context.Background(),
		`INSERT INTO indexed_files (file_path, content, embedding, summary) VALUES ($1, $2, $3, $4)
		 ON CONFLICT (file_path) DO UPDATE SET content = EXCLUDED.content, embedding = EXCLUDED.embedding, summary = EXCLUDED.summary, indexed_at = NOW()`,
		path, content, embeddingStr, summary)
	if err != nil {
		log.Printf("Failed to store in PostgreSQL for %s: %v\n", path, err)
	}
}

func storeInNeo4j(path, summary string, driver neo4j.DriverWithContext) {
	ctx := context.Background()
	session := driver.NewSession(ctx, neo4j.SessionConfig{})
	defer session.Close(ctx)

	_, err := session.ExecuteWrite(ctx, func(tx neo4j.ManagedTransaction) (any, error) {
		_, err := tx.Run(ctx,
			`MERGE (f:File {path: $path})
			 SET f.lastIndexed = datetime()
			 MERGE (s:Summary {text: $summary})
			 MERGE (f)-[:HAS_SUMMARY]->(s)`,
			map[string]any{"path": path, "summary": summary})
		return nil, err
	})
	if err != nil {
		log.Printf("Failed to store in Neo4j for %s: %v\n", path, err)
	}
}

func notifySvelteKit(endpoint string, payload any) {
	jsonData, _ := sonic.Marshal(payload)
	_, err := http.Post(fmt.Sprintf("%s%s", sveltekitAPI, endpoint), "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		log.Printf("Failed to send notification to SvelteKit endpoint %s: %v\n", endpoint, err)
	}
}
