/**
 * Determinism & Evaluation Service - Step 10 Implementation
 * Tracks agent actions, user feedback, and test results for RL/benchmarking
 */

import { librarySyncService } from "./library-sync-service.js";
import { redisVectorService } from "./redis-vector-service.js";

export interface EvaluationMetric {
  id: string;
  name: string;
  description: string;
  type:
    | "accuracy"
    | "relevance"
    | "completeness"
    | "consistency"
    | "efficiency";
  value: number;
  maxValue: number;
  timestamp: Date;
  context?: Record<string, any>;
}

export interface UserFeedback {
  id: string;
  sessionId: string;
  agentType: string;
  operation: string;
  query: string;
  response: any;
  rating: number; // 1-5 scale
  feedback: string;
  timestamp: Date;
  metadata?: Record<string, any>;
}

export interface TestResult {
  id: string;
  testType: "unit" | "integration" | "e2e" | "performance" | "accuracy";
  testName: string;
  passed: boolean;
  score?: number;
  duration: number;
  timestamp: Date;
  details?: any;
  agentInvolved?: string;
}

export interface RLFeatures {
  queryComplexity: number;
  contextSize: number;
  agentChainLength: number;
  responseTime: number;
  userSatisfaction: number;
  technicalAccuracy: number;
  previousSuccessRate: number;
}

class DeterminismEvaluationService {
  private readonly DETERMINISM_SEED = 42;
  private readonly LLM_TEMPERATURE = 0;

  /**
   * Set deterministic parameters for LLM calls
   */
  getDeterministicConfig(): Record<string, any> {
    return {
      temperature: this.LLM_TEMPERATURE,
      seed: this.DETERMINISM_SEED,
      top_p: 1.0,
      frequency_penalty: 0,
      presence_penalty: 0,
    };
  }

  /**
   * Record user feedback
   */
  async recordUserFeedback(
    feedback: Omit<UserFeedback, "id" | "timestamp">
  ): Promise<string> {
    const feedbackRecord: UserFeedback = {
      id: crypto.randomUUID(),
      timestamp: new Date(),
      ...feedback,
    };

    try {
      // Store in vector DB for semantic search
      await redisVectorService.storeDocument({
        id: `feedback_${feedbackRecord.id}`,
        content: `Query: ${feedback.query}\nFeedback: ${feedback.feedback}\nRating: ${feedback.rating}`,
        embedding: [], // Would be generated by embedding service
        metadata: {
          type: "chat", // Using existing type from VectorDocument interface
          agentType: feedback.agentType,
          operation: feedback.operation,
          rating: feedback.rating,
          sessionId: feedback.sessionId,
          timestamp: feedbackRecord.timestamp.toISOString(),
          documentType: "user_feedback",
        },
      });

      // Log the feedback as an agent call
      await librarySyncService.logAgentCall({
        id: crypto.randomUUID(),
        timestamp: new Date(),
        agentType: "evaluation",
        operation: "record_feedback",
        input: { feedbackId: feedbackRecord.id, rating: feedback.rating },
        output: { recorded: true },
        duration: 0,
        success: true,
        metadata: {
          originalAgentType: feedback.agentType,
          originalOperation: feedback.operation,
          userRating: feedback.rating,
        },
      });

      console.log(
        `üìù Recorded user feedback: ${feedback.rating}/5 for ${feedback.agentType}/${feedback.operation}`
      );
      return feedbackRecord.id;
    } catch (error) {
      console.error("Failed to record user feedback:", error);
      throw error;
    }
  }

  /**
   * Record test results
   */
  async recordTestResult(
    testResult: Omit<TestResult, "id" | "timestamp">
  ): Promise<string> {
    const testRecord: TestResult = {
      id: crypto.randomUUID(),
      timestamp: new Date(),
      ...testResult,
    };

    try {
      // Store in vector DB
      const content = `Test: ${testResult.testName}\nType: ${testResult.testType}\nResult: ${testResult.passed ? "PASSED" : "FAILED"}\nScore: ${testResult.score || "N/A"}\nDuration: ${testResult.duration}ms`;

      await redisVectorService.storeDocument({
        id: `test_${testRecord.id}`,
        content,
        embedding: [], // Would be generated by embedding service
        metadata: {
          type: "code", // Using existing type from VectorDocument interface
          testType: testResult.testType,
          testName: testResult.testName,
          passed: testResult.passed,
          score: testResult.score,
          duration: testResult.duration,
          agentInvolved: testResult.agentInvolved,
          timestamp: testRecord.timestamp.toISOString(),
          documentType: "test_result",
        },
      });

      // Log the test result
      await librarySyncService.logAgentCall({
        id: crypto.randomUUID(),
        timestamp: new Date(),
        agentType: "evaluation",
        operation: "record_test_result",
        input: { testName: testResult.testName, testType: testResult.testType },
        output: { passed: testResult.passed, score: testResult.score },
        duration: testResult.duration,
        success: testResult.passed,
        metadata: {
          testId: testRecord.id,
          agentInvolved: testResult.agentInvolved,
        },
      });

      console.log(
        `üß™ Recorded test result: ${testResult.testName} - ${testResult.passed ? "PASSED" : "FAILED"}`
      );
      return testRecord.id;
    } catch (error) {
      console.error("Failed to record test result:", error);
      throw error;
    }
  }

  /**
   * Calculate evaluation metrics
   */
  async calculateMetrics(
    agentType?: string,
    timeWindow?: number
  ): Promise<EvaluationMetric[]> {
    try {
      const metrics: EvaluationMetric[] = [];
      const timeFilter = timeWindow
        ? Date.now() - timeWindow * 60 * 60 * 1000
        : null;

      // Get recent feedback and test results
      const feedback = await this.getRecentFeedback(agentType, timeFilter);
      const testResults = await this.getRecentTestResults(
        agentType,
        timeFilter
      );
      const agentLogs = await librarySyncService.getRecentAgentLogs(
        agentType as any,
        100
      );

      // Calculate accuracy metric
      if (testResults.length > 0) {
        const passedTests = testResults.filter((t) => t.passed).length;
        const accuracy = passedTests / testResults.length;

        metrics.push({
          id: crypto.randomUUID(),
          name: "Test Accuracy",
          description: "Percentage of tests that passed",
          type: "accuracy",
          value: accuracy,
          maxValue: 1.0,
          timestamp: new Date(),
          context: { testCount: testResults.length, passedTests },
        });
      }

      // Calculate user satisfaction metric
      if (feedback.length > 0) {
        const avgRating =
          feedback.reduce((sum, f) => sum + f.rating, 0) / feedback.length;
        const satisfaction = avgRating / 5.0; // Normalize to 0-1

        metrics.push({
          id: crypto.randomUUID(),
          name: "User Satisfaction",
          description: "Average user rating (1-5 scale)",
          type: "relevance",
          value: satisfaction,
          maxValue: 1.0,
          timestamp: new Date(),
          context: { feedbackCount: feedback.length, avgRating },
        });
      }

      // Calculate efficiency metric
      if (agentLogs.length > 0) {
        const avgDuration =
          agentLogs.reduce((sum, log) => sum + log.duration, 0) /
          agentLogs.length;
        const successRate =
          agentLogs.filter((log) => log.success).length / agentLogs.length;

        metrics.push({
          id: crypto.randomUUID(),
          name: "Efficiency",
          description: "Success rate and average response time",
          type: "efficiency",
          value: successRate,
          maxValue: 1.0,
          timestamp: new Date(),
          context: { avgDuration, successRate, logCount: agentLogs.length },
        });
      }

      // Calculate consistency metric
      const consistency = await this.calculateConsistencyScore(agentType);
      if (consistency !== null) {
        metrics.push({
          id: crypto.randomUUID(),
          name: "Consistency",
          description: "Consistency of responses to similar queries",
          type: "consistency",
          value: consistency,
          maxValue: 1.0,
          timestamp: new Date(),
        });
      }

      return metrics;
    } catch (error) {
      console.error("Failed to calculate metrics:", error);
      return [];
    }
  }

  /**
   * Extract features for reinforcement learning
   */
  async extractRLFeatures(
    query: string,
    context: any,
    agentChain: string[],
    responseTime: number,
    userRating?: number
  ): Promise<RLFeatures> {
    try {
      // Calculate query complexity (simple heuristic)
      const queryComplexity = this.calculateQueryComplexity(query);

      // Context size
      const contextSize = JSON.stringify(context).length;

      // Get historical success rate for similar queries
      // Note: This would require implementing text search or using embeddings
      // For now, return default value
      const previousSuccessRate = 0.8;

      // Technical accuracy (placeholder - would be calculated from test results)
      const technicalAccuracy = 0.85;

      return {
        queryComplexity,
        contextSize,
        agentChainLength: agentChain.length,
        responseTime,
        userSatisfaction: userRating ? userRating / 5.0 : 0.5,
        technicalAccuracy,
        previousSuccessRate,
      };
    } catch (error) {
      console.error("Failed to extract RL features:", error);
      // Return default features
      return {
        queryComplexity: 0.5,
        contextSize: 1000,
        agentChainLength: 1,
        responseTime,
        userSatisfaction: 0.5,
        technicalAccuracy: 0.5,
        previousSuccessRate: 0.5,
      };
    }
  }

  /**
   * Get benchmark results
   */
  async getBenchmarkResults(agentType?: string): Promise<{
    metrics: EvaluationMetric[];
    trends: Record<string, number[]>;
    recommendations: string[];
  }> {
    try {
      const metrics = await this.calculateMetrics(agentType, 24); // Last 24 hours

      // Get trends (placeholder - would calculate from historical data)
      const trends = {
        accuracy: [0.85, 0.87, 0.86, 0.88, 0.89],
        satisfaction: [0.75, 0.78, 0.76, 0.8, 0.82],
        efficiency: [0.92, 0.91, 0.93, 0.9, 0.94],
      };

      // Generate recommendations
      const recommendations = await this.generateRecommendations(metrics);

      return {
        metrics,
        trends,
        recommendations,
      };
    } catch (error) {
      console.error("Failed to get benchmark results:", error);
      return { metrics: [], trends: {}, recommendations: [] };
    }
  }

  /**
   * Calculate query complexity
   */
  private calculateQueryComplexity(query: string): number {
    // Simple heuristic based on length, special chars, and keywords
    const length = query.length;
    const words = query.split(/\s+/).length;
    const hasCode = /```|`[^`]+`/.test(query);
    const hasQuestions = /\?/.test(query);
    const hasComplexTerms =
      /\b(algorithm|implementation|architecture|integration|optimization)\b/i.test(
        query
      );

    let complexity = Math.min(length / 500, 1.0); // Base on length
    if (hasCode) complexity += 0.2;
    if (hasQuestions) complexity += 0.1;
    if (hasComplexTerms) complexity += 0.3;
    if (words > 20) complexity += 0.2;

    return Math.min(complexity, 1.0);
  }

  /**
   * Calculate historical success rate
   */
  private async calculateHistoricalSuccessRate(
    similarQueries: any[]
  ): Promise<number> {
    // Placeholder implementation
    return 0.8;
  }

  /**
   * Calculate consistency score
   */
  private async calculateConsistencyScore(
    agentType?: string
  ): Promise<number | null> {
    // Placeholder implementation - would analyze response similarity for similar queries
    return 0.85;
  }

  /**
   * Get recent feedback
   */
  private async getRecentFeedback(
    agentType?: string,
    timeFilter?: number | null
  ): Promise<UserFeedback[]> {
    try {
      // For now, return empty array as we need to implement text search or use Redis keys
      // This would require building a proper search index or using embeddings
      console.log(
        "Getting recent feedback - implementation needed for full text search"
      );
      return [];
    } catch (error) {
      console.error("Failed to get recent feedback:", error);
      return [];
    }
  }

  /**
   * Get recent test results
   */
  private async getRecentTestResults(
    agentType?: string,
    timeFilter?: number | null
  ): Promise<TestResult[]> {
    try {
      // For now, return empty array as we need to implement text search or use Redis keys
      // This would require building a proper search index or using embeddings
      console.log(
        "Getting recent test results - implementation needed for full text search"
      );
      return [];
    } catch (error) {
      console.error("Failed to get recent test results:", error);
      return [];
    }
  }

  /**
   * Generate recommendations based on metrics
   */
  private async generateRecommendations(
    metrics: EvaluationMetric[]
  ): Promise<string[]> {
    const recommendations: string[] = [];

    for (const metric of metrics) {
      if (metric.value < 0.7) {
        switch (metric.type) {
          case "accuracy":
            recommendations.push(
              "Consider improving test coverage and validation logic"
            );
            break;
          case "relevance":
            recommendations.push(
              "Enhance query understanding and response relevance"
            );
            break;
          case "efficiency":
            recommendations.push("Optimize response times and error handling");
            break;
          case "consistency":
            recommendations.push(
              "Standardize response formats and improve determinism"
            );
            break;
        }
      }
    }

    if (recommendations.length === 0) {
      recommendations.push("System performance is good - continue monitoring");
    }

    return recommendations;
  }
}

export const determinismEvaluationService = new DeterminismEvaluationService();
