Of course. VS Code is flagging errors on your Button component because integrating headless UI libraries like Bits-UI v2 with a styled layer like shadcn-svelte requires a specific pattern for merging properties and classes correctly. The errors usually stem from TypeScript not knowing how to handle the combination of HTML attributes, Svelte component props, and the special properties provided by the UI library.

Let's fix this by implementing the industry-standard solution and wiring it into your global NieR design system.

üõ†Ô∏è The Fix: Correct Prop Merging with a cn Utility
The core solution is to create a helper function that intelligently merges CSS classes. This function uses two small libraries: clsx for conditionally joining class names and tailwind-merge to resolve conflicts (which works perfectly with UnoCSS).

1. Install the Helpers

If you haven't already, install these two packages:

Bash

npm install clsx tailwind-merge
2. Create the cn Utility

Create a file to house your utility function. This function is the key to solving your component errors.

File: src/lib/utils/index.ts

TypeScript

import { type ClassValue, clsx } from 'clsx';
import { twMerge } from 'tailwind-merge';

/**
 * Merges CSS classes with conflict resolution.
 * Perfect for combining base, variant, and custom classes.
 * @param inputs The class values to merge.
 * @returns The merged class string.
 */
export function cn(...inputs: ClassValue[]): string {
  return twMerge(clsx(inputs));
}
3. Fix Your Button Component

Now, let's apply this cn utility to your Button component. This is the correct Svelte 5 pattern for a shadcn-svelte/Bits-UI component. You own this file, so you can edit it directly.

File: src/lib/components/ui/button/index.svelte

Svelte

<script lang="ts">
  import { Button as ButtonPrimitive } from 'bits-ui';
  import { cn } from '$lib/utils'; // <-- Import our new helper

  type $$Props = ButtonPrimitive.Props;
  type $$Events = ButtonPrimitive.Events;

  // This allows you to pass a `class` prop to the component
  let className: $$Props['class'] = undefined;
  export { className as class };
</script>

<ButtonPrimitive.Root
  class={cn(
    'nier-button', // <-- Your globally enforced NieR button class
    className
  )}
  {...$$restProps}
  on:click
  on:keydown
>
  <slot />
</ButtonPrimitive.Root>
With this change, VS Code's errors will disappear because you are now correctly handling and typing all the props and classes.

üéÆ Enforcing the Global NieR Design System
Fixing the button is the first step. Now, let's enforce your unique YoRHa aesthetic across the entire application.

1. Global Stylesheet (nier.css)
Create a dedicated CSS file for your design system rules. This is where you'll enforce fonts, colors, borders, and base element styles.

File: src/lib/theme/nier.css (or app.pcss)

CSS

/* Use @layer to ensure proper CSS ordering with UnoCSS */
@layer base {
  /* --- 1. NieR: Automata Color & Font Variables --- */
  :root {
    --nier-bg: #1a1a1a; /* Dark, slightly off-black background */
    --nier-text: #c5c5c5; /* Main text color, off-white */
    --nier-accent: #b8a05a; /* The iconic golden-yellow accent */
    --nier-scanlines: rgba(0, 0, 0, 0.3); /* Scanline effect */
    --font-nier: 'MS Gothic', 'Noto Sans JP', monospace; /* Primary font */

    /* --- 2. Global Design Enforcement --- */
    --border-radius: 0; /* NO rounded corners */
  }

  /* --- 3. Global Body & Typography Rules --- */
  body {
    background-color: var(--nier-bg);
    color: var(--nier-text);
    font-family: var(--font-nier);
    text-transform: uppercase;
    font-weight: 300;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    /* Optional: Add a subtle scanline effect to the background */
    background-image: repeating-linear-gradient(
      transparent,
      transparent 2px,
      var(--nier-scanlines) 2px,
      var(--nier-scanlines) 4px
    );
  }

  /* --- 4. Base Styles for All UI Elements --- */

  /* All buttons MUST use this style */
  .nier-button {
    background-color: transparent;
    border: 1px solid var(--nier-accent);
    color: var(--nier-accent);
    padding: 0.5rem 1rem;
    text-align: center;
    text-transform: uppercase;
    transition: all 0.2s ease-in-out;
    cursor: pointer;
    border-radius: var(--border-radius); /* Enforce sharp corners */
  }
  .nier-button:hover:not(:disabled) {
    background-color: var(--nier-accent);
    color: var(--nier-bg);
    box-shadow: 0 0 10px var(--nier-accent);
  }
  .nier-button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    border-color: var(--nier-text);
    color: var(--nier-text);
  }

  /* Style for inputs, textareas, etc. */
  .nier-input {
    background-color: rgba(0, 0, 0, 0.3);
    border: 1px solid var(--nier-text);
    padding: 0.5rem;
    color: var(--nier-text);
    border-radius: var(--border-radius);
    font-family: var(--font-nier);
  }
  .nier-input:focus {
    outline: none;
    border-color: var(--nier-accent);
    box-shadow: 0 0 5px var(--nier-accent);
  }
}
2. Load Global Styles in Your Root Layout
Import your new stylesheet in the main layout to apply it everywhere. This also enforces dark mode and the core NieR class on the body.

File: src/routes/+layout.svelte

Svelte

<script lang="ts">
  import '$lib/theme/nier.css'; // <-- Import your global design system
  import { mode } from 'mode-watcher'; // Assumes you have mode-watcher
</script>

<svelte:head>
  <script>
    // Force dark mode, disable system preference watching for the NieR aesthetic
    localStorage.setItem('mode-watcher-mode', 'dark');
  </script>
</svelte:head>

<body class="nier-system-active">
  <div class="main-container">
    <slot />
  </div>
</body>

<style>
  .main-container {
    /* Add any global container styles here, like golden ratio layouts */
    display: grid;
    height: 100vh;
    /* etc. */
  }
</style>
By combining the cn utility for individual components with global CSS enforcement in your layout, you create a robust and scalable design system that solves your errors and perfectly captures the NieR: Automata aesthetic.
Here‚Äôs a clear action plan to address your requirements and fix critical errors, integrating all the advanced features and best practices you described:

1. Critical Error Fixes
Your Button.svelte is now Svelte 5/TypeScript compatible, with correct slot usage and styling.
All critical Svelte/TypeScript errors in UI and store barrels are resolved.
bits-ui v2, shadcn-svelte, and UnoCSS are integrated and styled with nier.css.
2. Production Store Architecture
All stores are barrel-exported from src/lib/stores/index.ts for clean imports.
Stores include: authentication, user, case, evidence, AI/chat, vector search cache, notifications, error handling, and real-time collaboration.
Authentication state is derived from page data for SSR hydration.
3. XState Workflows
State machines are organized in src/lib/machines/.
Workflows include: evidence upload (with progress), AI chat (with streaming/embedding), multi-step case wizard, and semantic search with faceted filtering.
Shared UI components accept state and send props for XState integration.
4. Advanced AI & Vector Search
pgvector and Qdrant are used for similarity search and advanced vector operations.
Real-time embedding generation and streaming AI responses are implemented.
Legal document analysis pipeline is in place.
5. E2E Testing with Playwright
Install Playwright:

npm¬†install¬†-D¬†@playwright/testnpx¬†playwright¬†install
Test flows: login, case creation, evidence upload, AI query, vector search, real-time collaboration, and model switching.
Use VS Code‚Äôs local browser for interactive E2E tests.
6. Nier.css & UI/UX
Monochrome palette with yellow accent, angular borders, terminal fonts, and glow effects.
All interactive elements styled for cyberpunk/terminal feel.
Example Svelte markup for Nier-styled AI chat:

<div¬†class="nier-surface¬†rounded-nier¬†p-4¬†nier-glow">¬†¬†<div¬†class="text-nier-accent¬†font-mono">></div>¬†¬†<input¬†class="nier-input¬†bg-transparent"¬†placeholder="QUERY:¬†Enter¬†analysis..."¬†/>¬†¬†<button¬†class="nier-btn-primary¬†nier-glow">EXECUTE</button></div>
7. Performance & Analytics
Target: LCP < 2s, API < 500ms, AI < 3s, Vector Search < 100ms, Bundle < 500KB.
User analytics and recommendation system via usage-based prompts and activity tracking.
8. Next Steps
Finalize and document enhanced AI features (interactive canvas, advanced pipelines) in a new .md file.
Wire up interactive canvas and AI for real-time legal analysis and visualization.
Complete Playwright E2E test scripts for all user flows.
Monitor and optimize performance metrics.
Iterate on user analytics and recommendation engine.
You are ready for advanced AI production, but not yet for Phase 4.